import { Token, TokenLiteral } from "./Token";
import { TokenType } from "./TokenType";

/**
 * Sugar type for a single character.
 * Actually checking for string length here is likely less performant than just using a string
 *
 * @link https://stackoverflow.com/questions/42678891/typescript-character-type
 */
export type char = string;

/**
 * A list of characters that are considered punctuation.
 * These characters do NOT parse to special tokens when found in the middle of a word.
 *
 * @example foo-bar: the dash is not parsed to a token
 * @example foo`bar`: the backtick IS parsed as a token, so it's not in this list
 */
export const PUNCTUATION = [
	"!",
	"@",
	"^",
	"&",
	"-",
	"_",
	"=",
	" ",
	",",
	".",
	"|",
	"(",
	")",
	"{",
	"}",
];

export class Tokenizer {
	source: string;
	c: char;
	column = 0;
	current = 0;
	start = 0;
	line = 1;
	tokens: Token[] = [];

	constructor(source: string) {
		this.source = source;
	}

	/**
	 * Adds a token to the token list.
	 * @param type The type of token to add
	 * @param literalValue The literal value of the token. If not provided, the lexeme is used.
	 */
	protected addToken(type: TokenType, literalValue?: TokenLiteral): void {
		const lexeme = this.source.substring(this.start, this.current);
		const literal = literalValue ?? lexeme;
		const token = new Token(type, lexeme, literal, this.line, this.column);

		this.tokens.push(token);
		this.start = this.current;
		this.column += lexeme.length;
		this.advance();
	}

	/**
	 * Adds tokens from a sub-tokenizer to the token list.
	 * This is helpful when parsing inside of a code block, a table, or another decorated block.
	 *
	 * @param tokens The tokens generated by the sub-tokenizer
	 */
	protected addTokensFromSubTokenizer(tokens: Token[]): void {
		let columnCount = 0;
		for (const token of tokens) {
			if (token.type === TokenType.EOF) {
				continue;
			}
			columnCount += token.lexeme.length;
			this.tokens.push(token);
		}

		this.start = this.current;
		this.column += columnCount;
		this.advance();
	}

	/**
	 * Advances the current character position and returns the character at the new position.
	 * @returns The next character in the source string, or undefined if the end of the source string has been reached.
	 */
	protected advance(steps = 1): string {
		const nextIndex = this.current + steps;
		this.c = this.source.charAt(nextIndex - 1);
		this.current = nextIndex;
		return this.c;
	}

	/**
	 * Returns true if the current character is the end of the source string.
	 * @returns True if the current character is the end of the source string.
	 */
	protected eof(): boolean {
		return this.current > this.source.length;
	}

	/**
	 * Scan the source string and return the list of tokens.
	 * @returns The list of tokens scanned from the source string.
	 */
	public getTokens(): Token[] {
		this.advance();

		while (!this.eof()) {
			this.scanLine();
		}

		this.scanEof();
		return this.tokens;
	}

	/**
	 * Returns true if the character is a letter.
	 * @param c The character to check
	 * @returns
	 */
	protected isAlpha(c: char | undefined): boolean {
		if (c === undefined) {
			return false;
		}

		return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z");
	}

	/**
	 * Returns true if the character is a letter or number.
	 * @param c The character to check
	 * @returns True if the character is a letter or number.
	 */
	protected isAlphaNumeric(c: char | undefined): boolean {
		if (c === undefined) {
			return false;
		}

		return (
			(c >= "a" && c <= "z") ||
			(c >= "A" && c <= "Z") ||
			(c >= "0" && c <= "9")
		);
	}

	/**
	 * Returns true if the character is a letter, number, or punctuation.
	 * See the PUNCTUATION constant for a list of punctuation characters.
	 *
	 * @param c The character to check
	 * @returns True if the character is a letter, number, or punctuation.
	 */
	protected isAlphaOrPunctuation(c: char | undefined): boolean {
		if (c === undefined) {
			return false;
		}

		return (
			(c >= "a" && c <= "z") ||
			(c >= "A" && c <= "Z") ||
			// (c >= "0" && c <= "9") ||
			PUNCTUATION.includes(c)
		);
	}

	/**
	 * Returns true if the character is a new line character.
	 * @param c The character to check
	 * @returns True if the character is a new line character.
	 */
	protected isNewLine(c: char | undefined): boolean {
		return c === "\n";
	}

	/**
	 * Returns true if the character is a number.
	 * @param c The character to check
	 * @returns True if the character is a number.
	 */
	protected isNumeric(c: char | undefined): boolean {
		return c !== undefined && c >= "0" && c <= "9";
	}

	/**
	 * Returns true if the character is a space or tab character.
	 * @param c The character to check
	 * @returns True if the character is a space or tab character.
	 */
	protected isSpace(c: char | undefined): boolean {
		return c === " " || c === "\t";
	}

	/**
	 * Returns true if the next character in the source string matches the expected character.
	 * @param expected The character to match
	 * @returns True if the next character in the source string matches the expected character.
	 */
	protected match(expected: string): boolean {
		return !this.eof() && this.peek() === expected;
	}

	/**
	 * Returns the next character in the source string without advancing the current character position.
	 * @returns The next character in the source string, or undefined if the end of the source string has been reached.
	 */
	protected peek(): string {
		return this.peekFar(0);
	}

	/**
	 * Returns the nth next character in the source string without advancing the current character position.
	 * @param n The number of characters to peak ahead
	 * @returns The nth next character in the source string, or undefined if the end of the source string has been reached.
	 */
	protected peekFar(n: number): string {
		if (this.current + n >= this.source.length) {
			return "\0";
		}
		return this.source.charAt(this.current + n);
	}

	/**
	 * Returns the second next character in the source string without advancing the current character position.
	 * @returns The second next character in the source string, or undefined if the end of the source string has been reached.
	 */
	protected peekNext(): string {
		return this.peekFar(1);
	}

	/**
	 * Scans a backtick, adding a backtick token to the token list.
	 * Also scans for triple backticks, adding a triple backtick token to the token list if found.
	 */
	protected scanBacktick(): void {
		if (this.match("`") && this.peekNext() === "`") {
			this.advance(2);
			this.addToken(TokenType.TRIPLE_BACKTICK);
		}
		this.addToken(TokenType.BACKTICK);
	}

	/**
	 * Scans a bullet lexeme, adding a bullet token to the token list.
	 */
	protected scanBullet(): void {
		while (this.isSpace(this.peek())) {
			this.advance();
		}

		const nextChar = this.peek();
		const midChar = this.peekNext();
		const lastChar = this.peekFar(2);

		if (
			nextChar === "[" &&
			[" ", "x"].includes(midChar) &&
			lastChar === "]"
		) {
			this.advance(3);
			this.addToken(TokenType.CHECKBOX, midChar === "x");
			return this.scanWordsAndPunctuation();
		}

		this.addToken(TokenType.BULLET);
		this.scanWordsAndPunctuation();
	}

	/**
	 * Scans a colon, adding a colon token to the token list.
	 * Also scans for a second colon, adding a double colon token to the token list if found.
	 */
	protected scanColon(): void {
		if (this.match(":")) {
			this.advance();
			this.addToken(TokenType.COLON_COLON);
		} else {
			this.addToken(TokenType.COLON);
		}
	}

	/**
	 * Scans a dash, adding a dash token to the token list.
	 * Also scans for a triple dash, adding a triple dash token to the token list if found.
	 */
	protected scanDash(): void {
		if (this.match("-") && this.peekNext() === "-") {
			this.advance(2);
			this.addToken(TokenType.TRIPLE_DASH);
		}

		this.scanWordsAndPunctuation();
	}

	/**
	 * Scans a dollar, adding a dollar token to the token list.
	 * Also scans for a triple dollar, adding a triple dollar token to the token list if found.
	 */
	protected scanDollar(): void {
		if (this.match("$") && this.peekNext() === "$") {
			this.advance(2);
			this.addToken(TokenType.TRIPLE_DOLLAR);
		} else {
			this.addToken(TokenType.DOLLAR);
		}
	}

	/**
	 * Scans the end of file, adding an EOF token to the token list.
	 */
	protected scanEof(): void {
		this.addToken(TokenType.EOF, "\0");
	}

	/**
	 * Scans an escape character, adding an escape token to the token list.
	 */
	protected scanEscape(): void {
		this.advance();
		this.addToken(TokenType.ESCAPE);
	}

	/**
	 * Scans an exclamation mark, adding an exclamation mark token to the token list.
	 */
	protected scanExclamation(): void {
		if (this.match("[") && this.peekNext() === "[") {
			this.advance(2);
			this.addToken(TokenType.ILL_BRACKET);
		} else {
			this.scanText();
		}
	}

	/**
	 * Scans a header lexeme, adding a header token to the token list.
	 * The header is ONLY the hash tags and the spacer characters after the hash tags.
	 */
	protected scanHash(): void {
		let hashCount = 1;

		while (this.match("#")) {
			hashCount++;
			this.advance();
		}

		while (this.isSpace(this.peek())) {
			this.advance();
		}

		this.addToken(TokenType.HEADER, hashCount);
		this.scanWordsAndPunctuation();
	}

	/**
	 * Scans a left angle, adding a left angle token to the token list.
	 */
	protected scanLeftAngle(): void {
		if (this.match("%")) {
			this.advance(2);
			this.addToken(TokenType.LP_ANGLE_BRACKET);
		} else {
			this.addToken(TokenType.L_ANGLE_BRACKET);
		}
	}

	/**
	 * Scans a left bracket, adding a left bracket token to the token list.
	 * Also scans for a second left bracket, adding a double left bracket token to the token list if found.
	 */
	protected scanLeftBracket(): void {
		if (this.match("[")) {
			this.advance();
			this.addToken(TokenType.LL_BRACKET);
		} else {
			this.addToken(TokenType.L_BRACKET);
		}
	}

	/**
	 * Scans a left parenthesis, adding a left parenthesis token to the token list.
	 */
	protected scanLeftParen(): void {
		this.addToken(TokenType.L_PAREN);
	}

	/**
	 * Scans the current line for tokens
	 */
	protected scanLine(): void {
		switch (this.c) {
			case "#":
				return this.scanHash();
			case "-":
				if (this.match(" ")) {
					return this.scanBullet();
				} else {
					return this.scanDash();
				}
			case "\n":
				return this.scanNewLine();
			case "\t":
			case " ":
				return this.scanTab();
			case ">":
				return this.scanLineQuote();
			case "|":
				return this.scanTableRow();
			case "1":
			case "2":
			case "3":
			case "4":
			case "5":
			case "6":
			case "7":
			case "8":
			case "9":
				return this.scanNumberedBullet();
			default:
				return this.scanWordsAndPunctuation();
		}
	}

	/**
	 * Scans for a numbered bullet at the start of a line.
	 */
	protected scanNumberedBullet(): void {
		let number = this.c;

		while (this.isNumeric(this.peek())) {
			number += this.advance();
		}

		if (this.match(".")) {
			this.advance();
			if (this.isSpace(this.peek())) {
				this.addToken(TokenType.N_BULLET, parseInt(number, 10));
				return this.scanWordsAndPunctuation();
			}
		}

		return this.scanWordsAndPunctuation();
	}

	/**
	 * Scans a new line, adding a new line token to the token list.
	 */
	protected scanNewLine(): void {
		this.addToken(TokenType.NL);
		this.line++;
		this.column = 0;
	}

	/**
	 * Scans a number, adding a number token to the token list.
	 */
	protected scanNumber(): void {
		while (this.isNumeric(this.peek())) {
			this.advance();
		}

		if (this.match(".")) {
			this.advance();
			while (this.isNumeric(this.peek())) {
				this.advance();
			}
		}

		this.addToken(
			TokenType.NUMBER,
			parseFloat(this.source.substring(this.start, this.current))
		);
	}

	/**
	 * Scans a percent, adding a percent token to the token list.
	 * Also scans for a second percent, adding a double percent token to the token list if found.
	 */
	protected scanPercent(): void {
		if (this.match("%")) {
			this.advance();
			this.addToken(TokenType.PERCENT_PERCENT);
		} else if (this.match(">")) {
			this.advance();
			this.addToken(TokenType.RP_ANGLE_BRACKET);
		} else {
			this.scanText();
		}
	}

	/**
	 * Scans a quote, adding a quote token to the token list.
	 * @example > quote
	 */
	protected scanLineQuote(): void {
		if (this.match(" ")) {
			this.addToken(TokenType.QUOTE);
		}
		return this.scanText();
	}

	/**
	 * Scans a right angle, adding a right angle token to the token list.
	 */
	protected scanRightAngle(): void {
		if (this.match(">")) {
			this.advance();
			this.addToken(TokenType.RR_ANGLE_BRACKET);
		} else {
			this.addToken(TokenType.R_ANGLE_BRACKET);
		}
	}

	/**
	 * Scans a right bracket, adding a right bracket token to the token list.
	 * Also scans for a second right bracket, adding a double right bracket token to the token list if found.
	 */
	protected scanRightBracket(): void {
		if (this.match("]")) {
			this.advance();
			this.addToken(TokenType.RR_BRACKET);
		} else {
			this.addToken(TokenType.R_BRACKET);
		}
	}

	/**
	 * Scans a right parenthesis, adding a right parenthesis token to the token list.
	 */
	protected scanRightParen(): void {
		this.addToken(TokenType.R_PAREN);
	}

	/**
	 * Scans a space, adding a space token to the token list.
	 */
	protected scanSpace(): void {
		while (this.isSpace(this.peek())) {
			this.advance();
		}

		this.addToken(TokenType.SPACE);
	}

	/**
	 * Scans a star, adding a star token to the token list.
	 * Also scans for a second star, adding a double star token to the token list if found.
	 */
	protected scanStar(): void {
		if (this.match("*")) {
			this.advance();
			this.addToken(TokenType.STAR_STAR);
		} else {
			this.addToken(TokenType.STAR);
		}
	}

	/**
	 * Scans a tab, adding a tab token to the token list.
	 */
	protected scanTab(): void {
		let tabCount = 1;
		const tabValue = this.c;

		while (this.peek() === tabValue) {
			this.advance();
			tabCount++;
		}

		this.addToken(TokenType.TAB, tabCount);
	}

	/**
	 * Scans a table bar, adding a bar token to the token list.
	 */
	protected scanTableBar(): void {
		while (!this.eof() && this.isSpace(this.peek())) {
			this.advance();
		}

		this.addToken(TokenType.BAR);
	}

	/**
	 * Scans a table row, adding tokens to the token list.
	 */
	protected scanTableRow(): void {
		this.scanTableBar();

		while (!this.eof() && !this.match("\n")) {
			if (this.c === "\\") {
				this.advance();
			}

			while (!this.eof() && !this.match("|") && !this.match("\n")) {
				if (this.c === "\\") {
					this.advance();
				}

				this.advance();
			}

			const cellValue = this.source.substring(this.start, this.current);
			const tokens = new Tokenizer(cellValue).getTokens();

			this.addTokensFromSubTokenizer(tokens);
			this.scanTableBar();
		}
	}

	/**
	 * Scans a tag, adding a tag token to the token list.
	 * @example #tag
	 */
	protected scanTag(): void {
		while (!this.eof() && this.isAlphaNumeric(this.peek())) {
			this.advance();
		}

		this.addToken(
			TokenType.TAG,
			this.source.substring(this.start + 1, this.current)
		);
	}

	/**
	 * Scans until the end of the current word, adding a word token to the token list.
	 */
	protected scanText(): void {
		if (this.isAlpha(this.c)) {
			while (this.isAlphaNumeric(this.peek())) {
				this.advance();
			}
		}

		if (this.isAlphaOrPunctuation(this.peek())) {
			while (this.isAlphaOrPunctuation(this.peek())) {
				this.advance();
			}
			this.addToken(TokenType.TEXT);
		} else {
			this.addToken(TokenType.SYMBOL);
		}
	}

	/**
	 * Scans a tilde, adding a tilde token to the token list.
	 * Also scans for a second tilde, adding a double tilde token to the token list if found.
	 */
	protected scanTilde(): void {
		if (this.match("~")) {
			this.advance();
			this.addToken(TokenType.TILDE_TILDE);
		} else {
			this.scanText();
		}
	}

	/**
	 * Scans an underscore, adding an underscore token to the token list.
	 */
	protected scanUnderscore(): void {
		if (this.match("_")) {
			this.advance();
			this.addToken(TokenType.DUNDERSCORE);
		} else {
			this.addToken(TokenType.UNDERSCORE);
		}
	}

	/**
	 * Scan until the end of the current line, adding tokens to the token list.
	 */
	protected scanWordsAndPunctuation(): void {
		let recursionValve = 100;

		while (recursionValve-- > 0 && !this.eof() && !this.isNewLine(this.c)) {
			switch (this.c) {
				case "\\":
					this.scanEscape();
					break;
				case "[":
					this.scanLeftBracket();
					break;
				case "]":
					this.scanRightBracket();
					break;
				case "#":
					if (this.isAlphaNumeric(this.peek())) {
						this.scanTag();
					} else {
						this.scanText();
					}
					break;
				case " ":
					this.scanSpace();
					break;
				case "(":
					this.scanLeftParen();
					break;
				case ")":
					this.scanRightParen();
					break;
				case "*":
					this.scanStar();
					break;
				case "_":
					this.scanUnderscore();
					break;
				case "~":
					this.scanTilde();
					break;
				case "!":
					this.scanExclamation();
					break;
				case ":":
					this.scanColon();
					break;
				case "`":
					this.scanBacktick();
					break;
				case "$":
					this.scanDollar();
					break;
				case "%":
					this.scanPercent();
					break;
				case "<":
					this.scanLeftAngle();
					break;
				case ">":
					this.scanRightAngle();
					break;
				default:
					if (this.isNumeric(this.c)) {
						this.scanNumber();
					} else if (this.isAlphaOrPunctuation(this.c)) {
						this.scanText();
					} else {
						throw new Error(
							`Unexpected character '${this.c}' at line ${this.line}, column ${this.column}`
						);
					}

					break;
			}
		}
	}
}
